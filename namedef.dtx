% \iffalse meta-comment
% Copyright (C) 2019--2020
% by Phelype Oleinik <phelype.oleinik@latex-project.org>
% 
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, either version 1.3c of this license
% or (at your option) any later version. The latest version of this
% license is in
% 
%     http://www.latex-project.org/lppl.txt
% 
% and version 1.3c or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
% 
% This work is "maintained" (as per the LPPL maintenance status)
% by Phelype Oleinik.
% 
%<*driver>
\documentclass[a4paper,full,inline]{l3doc}
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage{namedef}
\usepackage{bookmark}
\usepackage{xcolor}

\def\TODO#1#{\begingroup\afterassignment\TODODO\let\tmp = }
\def\TODODO{\setbox0=\vbox\bgroup\aftergroup\ENDTODO}
\def\ENDTODO{\endgroup\ignorespaces}

\begingroup
  \lccode`~=`\%
  \lowercase{\endgroup
  \def\VRBCodes{^^A
    \catcode`~=13
    \def~{\%\global\linenofalse}}
}
\makeatletter
\define@key{FV}{labelformat}{%
  \def\FV@LabelFormat{#1}%
  \ifx\FV@LabelFormat\FV@None
    \let\FV@LabelFormat\relax
  \fi}
\def\FV@Label@ii[#1]#2\@nil{%
  \def\@tempa{#1}%
  \ifx\@tempa\empty
    \def\FV@LabelBegin{\FV@LabelFormat#2}%
  \else
    \def\FV@LabelBegin{\FV@LabelFormat#1}%
    \def\FV@LabelPositionBottomLine{\@ne}%
  \fi
  \def\FV@LabelEnd{\FV@LabelFormat#2}}
\makeatother
\DefineVerbatimEnvironment%
  {example}{Verbatim}
  {
    gobble=3,
    frame=single,
    commandchars=|<>,
    codes={\VRBCodes},
    numbers=left,
    labelformat=\rmfamily\bfseries,
  }
\def\mshow#1{> \string#1=\meaning#1}
\newif\iflineno\linenotrue%\fi
\def\theFancyVerbLine{^^A
  \rmfamily
  \scriptsize
  \color{gray}^^A
  \iflineno
    \arabic{FancyVerbLine}^^A
  \else
    \global\addtocounter{FancyVerbLine}{-1}^^A
  \fi
  \global\linenotrue
}

% Substitute lmtt/it by lmtt/sl
\DeclareFontShape{T1}{lmtt}{lc}{it}{<->ssub*lmtt/lc/sl}{}

\begin{document}
  \overfullrule=5pt
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \GetFileInfo{\jobname.sty}
%
% \title{^^A
%   The \pkg{namedef} package\\
%   Using named parameters in definitions^^A
%   \thanks{This file has version number 0.2,
%           last revised \today.}
% }
%
% \author{^^A
%  Phelype H. Oleinik\thanks
%    {^^A
%      E-mail:
%        \href{mailto:phelype.oleinik@latex-project.org}
%          {phelype.oleinik\meta{at}latex-project.org}^^A
%    }^^A
% }
%
% \date{Released \today}
%
% \maketitle
%
% \begin{documentation}
%
% \section{Introduction}
%
% This package provides a somewhat dubious, however useful way to make
% \TeX{} definitions using \cs{def} and the like. The usual way to
% define a ``hello world'' macro is |\def\hello#1{Hello #1!}|. Sure,
% this is easy (for people using this package, at least), but sometimes
% I stumbled upon the case where I had a macro defined with something
% like |\def\macro#1#2#3#4#5#6{#6#1#4#3#5#2}| and then I had to, for
% whatever reason, add another argument before |#1|. Oh, the pain. But
% OK, occupational hazard. And then I change my mind and needed to
% revert.  This package provides a way to give a semantic meaning to the
% arguments of a definition such that it becomes clearer in meaning and
% easier to change when an argument's identifier defines what it means
% rather than its position in a list.
%
% \subsection{Features}
%
% This package defines a macro, \cs{named}, which acts like a prefix for
% \cs{def} (the same way as \cs{long} and the like), and allows one to
% rewrite the \cs{hello} macro like this:
% |\named\def\hello#[who]{Hello #[who]!}|. Sure, a macro with one
% argument won't see much benefit from it, but as soon as that number
% increases, a better description of the arguments comes in handy.
%
% The package also defines a macro \cs{NamedDelim} which allows the user
% to change the delimiter of the named parameters to their liking. For
% example, after |\NamedDelim //| the example above changes to:
% |\named\def\hello#/who/{Hello #/who/!}|. The default is
% |\NamedDelim []|.
%
% The only dependency of this package is the \LaTeX3 programming layer,
% \pkg{expl3}, thus this package works in any format and engine
% supported by \pkg{expl3}. In \LaTeXe, load it with
% |\usepackage{namedef}|, and in other formats with
% |\input namedef.sty|.
%
% \subsection{Feedback}
%
% Bugs, feature requests, or suggestions are most welcome.  You can send
% them by e-mail or to the source code repository at
% \url{https://github.com/PhelypeOleinik/namedef}.
%
% \section{Usage}
%
% \begin{function}{\named}
%   \begin{syntax}
%     \cs{named}\meta{other~prefixes}\meta{\cs[no-index]{(e,g,x)def}}^^A
%\meta{parameter text}\marg{replacement text}
%   \end{syntax}
%   The \cs{named} macro will grab the \meta{other~prefixes}, the
%   \cs{def} command, the \meta{parameter~text} and
%   \meta{replacement~text}, and will replace every ocurrence of
%   |#[|\meta{text}|]| by a suitable |#|\meta{number} for \TeX{} to
%   carry on with the definition.
%
%   The \meta{other~prefixes} can be any combination of \cs{long},
%   \cs{outer}, \cs{global}, and \cs{protected}. As for \TeX, their
%   relative order doesn't matter, except that \cs{named} must appear
%   \emph{before} any \cs{global} prefix.  Other prefixes are detected
%   whether placed before or after \cs{named}.
%
%   The \cs{def} command can be anything. The package will not check the
%   validity of the command, it will simply drag the token along until
%   the point where the definition is made. This allows one to use any
%   of \TeX's primitive \cs{def} commands as well as, for instance,
%   \pkg{expl3}'s \cs{cs_new:Npn} or the like. However \cs{named} will
%   not work with \LaTeX's \cs{newcommand} or \pkg{xparse}'s
%   \cs{NewDocumentCommand} and the like because their syntax is is
%   completely different.
%
%   The \meta{parameter~text} is the same \meta{parameter~text} that
%   would be used if the \cs{named} prefix wasn't used with the
%   difference that all |#|\meta{number} must be replaced by a
%   |#[|\meta{name}|]|. The characters |[| and |]| are mandatory and the
%   character |]| cannot appear in \meta{name}, however |[| and |]| can
%   still appear in the \meta{parameter~text} without restriction; the
%   special meaning is only applied after a parameter token (|#|).
%   \meta{name} can be anything that when fully expanded returns a
%   string of characters (anything valid in |\csname|\dots|\endcsname|).
%   The \meta{parameter~text} cannot, however, contain numbered
%   parameters anymore (|#1|,~|#2|,~\dots).
%
%   The \meta{replacement~text} is also the same \meta{replacement~text}
%   that would be used otherwise, with all |#|\meta{number} replaced by
%   |#[|\meta{name}|]|.
% \end{function}
%
% \begin{function}{\NamedDelim,\globalNamedDelim}
%   \begin{syntax}
%     \cs{NamedDelim}\meta{begin-token}\meta{end-token}
%     \cs{globalNamedDelim}\meta{begin-token}\meta{end-token}
%   \end{syntax}
%   These macros change the delimiter of the named parameters from the
%   default |#[|\meta{name}|]| to
%   |#|\meta{begin-token}\meta{name}\meta{end-token}. Both delimiters
%   must be one single non-macro token.  Valid delimiters are character
%   tokens with catcode $3$, $4$, $7$, $8$, $11$, or $12$
%   (see section~\ref{sec:delimiters}).
%
%   \cs{globalNamedDelim} is the same as \cs{NamedDelim} except that the
%   effect of the former has global scope, while the latter is local to
%   a group. While you can use both, you should be careful not to
%   interleave them too much or you might exhaust \TeX's save stack.
%
%   Furthermore, catcode changes to the delimiter will make the code not
%   work:
%   \begin{Verbatim}
%     \catcode`|=11
%     \NamedDelim{|}{|}
%     \catcode`|=12
%     \named\def\wrong#|oops|{#|oops|}
%   \end{Verbatim}
%   Other than that pretty much anything goes as delimiter, and it
%   doesn't matter if \meta{begin-token} and \meta{end-token} are the
%   same or not.
%
%   The choice of delimiter is mostly ``what you like better''. Neither
%   the delimter tokens nor the name of the parameter make it to the
%   macro itself. They are just code-level abstractions. Thus the
%   delimiter should be something that the person writing the code can
%   easily distinguish from the rest of the code. For example, the code
%   |\NamedDelim xz \named\def\test#xyz{xyz#xyzxyz}| works, but its
%   readability is questionable.
% \end{function}
%
% \subsection{Limitations}
%
% As already stated the command does not work (and I don't intend to
% make it work) with \LaTeXe's \cs{newcommand} and its family because
% a) the argument specification is by the number of arguments, so you
% can't ``declare'' them as with \cs{def}, and b) because it's supposed
% to be used for user-level interfaces, which usually (and preferably)
% have a low argument count, so numbering shouldn't be a problem.
% For \pkg{xparse}'s \cs{NewDocumentCommand} the situation is the same.
% Other than these, \cs{named} should work for whatever type of
% definition that uses the
% \meta{parameter~text}|{|\meta{replacement~text}|}| syntax.
%
% Another limitation that I'd like to change in a future release (but
% still don't know the best way to make the interface) is to support
% definition commands which go beyond the 
% \meta{parameter~text}|{|\meta{replacement~text}|}| syntax. For
% instance, in \pkg{expl3} a conditional that checks whether its
% argument is negative can be defined like this (for integers, of
% course):
% \begin{Verbatim}
%   \prg_new_conditional:Npnn \namedef_if_negative:n #1 { T, F, TF }
%     {
%       \if_int_compare:w #1 < 0
%         \prg_return_true:
%       \else:
%         \prg_return_false:
%       \fi:
%     }
% \end{Verbatim}
% And if one tried to use \cs{named} in that definition it would fail
% because this command takes one extra argument before the
% \meta{replacement~text}. Something could be done to allow one (or
% more) extra argument before the \meta{replacement~text}.
%
% \medskip
% One serious limitation is when used with definitions that expand their
% argument, namely \cs{edef} and \cs{xdef}. This type of definition
% expands tokens as it reads them, possibly changing their meaning
% during the process. \cs{named}, however, first grabs the definition as
% argument to process the named arguments before actually performing the
% definition, so these ``unexpected'' changes of meaning might make the
% code misbehave. While writing this manual I could think of two (and a
% half) situations which will be problematic and how to work around them
% (sorry, no solution for now; suggestions are welcome :).
%
%^^A \begingroup
% \edef\hash{\string#}
% \edef\¿{\csname @gobble\expandafter\endcsname\string\\}
% \def\nedeft{\ttfamily\¿named\¿edef\¿test}
%
% \subsubsection{\nedeft\{\¿string\#[arg]\}}
% \label{sec:edef wa1}
%
% The normal (no \cs{named}) counterpart of this one is a perfectly
% valid definition: |\edef\test{\string#1}|. While expanding the
% \meta{replacement~text}, \cs{string} turns the parameter token |#|$_6$
% into a character |#|$_{12}$, thus defining |\test| to expand to the
% two characters |#1|. When using \cs{named}, however, the replacement
% routine doesn't know what \cs{string} does to the token next to it, so
% it goes on and treats |#[arg]| as one named argument only to find out
% that it was never defined in the \meta{parameter~text}, so it aborts
% the definition with an error.
%
% This will occur in the specific case where the user wishes to have the
% macro expand to the characters |#[arg]|, without replacement by a
% parameter. In this case the work-around is to temporarily switch the
% delimiter tokens of \cs{named}'s scanner:
% \begin{Verbatim}
%   \NamedDelim||
%   \named\edef\test{\string#[arg]}
%   \NamedDelim[]
% \end{Verbatim}
% in which case the scanner will still see the |#| as a parameter token
% but since it is no longer followed by a delimiter, it will be simply
% passed on to the definition. Afterwards, at the time \TeX{} tries to
% carry on with the definition, \cs{string} will do its thing to |#|
% without further problems.
%
% \subsubsection{\nedeft\#[arg]\{\¿string\}\#[arg]\}}
% \label{sec:edef wa2}
%
% This one, as the previous, works fine without \cs{named}:
% |\edef\test#1{\string}#1}|. Again, when \TeX{} scans this definition,
% it will expand \cs{string} which will turn the end group token |}|$_2$
% into a character |}|$_{12}$, which will have \TeX{} end the definition
% with the next~|}|$_2$, after the |#1|. This only works because \TeX{}
% does not grab the whole thing as argument before expanding. Which is
% precisely what \cs{named} does.
%
% When \cs{named} grabs the definition as argument the first |}|
% ends the \meta{replacement~text}, so what \cs{named} effectively sees
% is |\edef\test#[arg]{\string}|, which is then processed (|#[arg]| is
% replaced by |#1|) and left back in the input stream for \TeX{} to do
% its thing, however the replacement |#[arg]| is never replaced:
% |\edef\test#1{\string}#[arg]}|, then when \TeX{} tries to do the
% definition it will complain about an ``! Illegal parameter number in
% definition of |\test|.''
%
% The work-around in this case is to do a dirty brace trick to lure
% \cs{named} into grabbing the whole thing as argument, but which will
% disappear at the time \TeX{} performs the expansion and definition.
% One option is |\iffalse{\fi|:
% \begin{Verbatim}
%   \named\edef\test#[arg]{%
%     \iffalse{\fi \string}#[arg]}
% \end{Verbatim}
% In this example \cs{named} will process everything, but at the time of
% the definition the entire |\iffalse{\fi| thing expands to nothing and
% the final definition becomes the same as the one without \cs{named}.
% The |\iffalse{\fi| block can also be left in the definition
% \emph{without} named and the result will be the same. One could argue
% that using the brace hack is safer because it doesn't change the
% definition, yet avoid problems when grabbing the definition as
% argument in a general situation.
%
% \let\SVsubsec\thesubsubsection
% \def\thesubsubsection{^^A
%   \thesubsection .\number\numexpr\value{subsubsection}-1,5}
%
% \subsubsection{\nedeft\#[arg]\{\¿string\{\#[arg]\}}
% \label{sec:edef wa3}
%
% \let\thesubsubsection\SVsubsec
%^^A \endgroup
%
% This is rather similar to the previous one, except that the brace
% later-to-be-detokenized begins a group: |\edef\test#1{\string{#1}|.
% Here \TeX{} also expands \cs{string} and makes |{|$_1$ a |{|$_{12}$
% which does not count in the brace balancing. \cs{named}, however, will
% count it when grabbing the definition as argument and will require one
% more |}|$_2$. If the code is run as is \TeX{} will probably report a
% ``File ended while scanning use of \dots'' error unless there happens
% to be a matching |}|$_2$ somewhere else, in which case the definition
% will just go wrong. The work-around here is the same as the one
% before, with |}| instead:
% \begin{Verbatim}
%   \named\edef\test#[arg]{%
%     \string{#[arg]\iffalse}\fi}
% \end{Verbatim}
% This will ensure that \cs{named} will see the |}| it needs to grab the
% definition correctly and will disappear once the definition is done.
%
% \subsection{Invalid delimiters}
% \label{sec:delimiters}
%
% The delimiters that can be used should be character tokens with
% catcode $3$, $4$, $7$, $8$, $11$, or $12$.  Characters with catcode
% $0$, $5$, $9$, $14$, and $15$ don't produce tokens to start with, so
% they can't possibly be used.  The remaining category codes are
% currently disallowed in the code because they make the input ambiguous
% or because they make the implementation more complex with no real
% advantage.
%
% Catcodes $1$ and $2$ (begin-/end-group) cannot be used because they
% become indistinguishable from the braces that delimit the
% \meta{parameter~text} of the definition, so the input is ambiguous.
%
% Catcode $6$ (macro parameter) cannot be used because it gets hard to
% distinguish a named parameter from some text surrounded by parameter
% tokens. For example in: |\named\edef\foo#name#{\string#then#name#}|,
% \pkg{namedef} would raise an error on |#then#| (unknown parameter)
% without knowing that the first |#|$_{6}$ becomes |#|$_{12}$ and the
% actual parameter is |#name#|\dots Or is it? I'm not entirely convinced
% of my own argument, so this might be implemented in the future.
%
% Catcode $10$ (blank space) is possible but it requires a hanful of
% extra precautions to avoid losing the space when passing arguments
% around.  Since it makes for a strange-looking syntax (our eyes are
% trained to ignore spaces), this is not supported.
%
% Catcode $13$ (active) should also be possible, but then the delimiter
% has to be identified by both character code and meaning.  I will
% likely implement this in the future.
%
% \section{Examples}
%
% The following examples show two definitions each, which are the same,
% but the second uses \cs{named}. The third line in each example shows
% the \cs{meaning} of the defined macro.
%
% First the basics, replacing a numbered parameter by a named one:
%   \named\def\hello#[who]{Hello #[who]!}
% \begin{example}[label=Basics]
%         \def\hello#1{Hello #1!}
%   \named\def\hello#[who]{Hello #[who]!}
%   |mshow|hello
% \end{example}
% \smallskip
%
% Prefixes can be added at will after the \cs{named} prefix:
%   \named\protected\long\edef\hello#[who]{Hello #[who]!}
% \begin{example}[label=Prefixes]
%         \protected\long\edef\hello#1{Hello #1!}
%   \named\protected\long\edef\hello#[who]{Hello #[who]!}
%   |mshow|hello
% \end{example}
% \smallskip
%
%^^A Whatever prefixes put before \cs{named} will be lost. Notice that
%^^A even though \cs{protected} is used, the macro itself is not defined
%^^A with \cs{protected}:
%^^A   \protected\named\long\edef\hello#[who]{Hello #[who]!}
%^^A \begin{example}[label=Wrong Prefixes]
%^^A   \protected      \long\edef\hello#1{Hello #1!}
%^^A   \protected\named\long\edef\hello#[who]{Hello #[who]!}
%^^A   |mshow|hello
%^^A \end{example}
%^^A \smallskip
%
% This example is just to show that the named argument delimiter doesn't
% interfere with the text in the macro:
%   \named\def\hello[#[who]]{Hello #[who]!}
% \begin{example}[label=Argument delimited by \texttt{[} and \texttt{]}]
%         \def\hello[#1]{Hello #1!}
%   \named\def\hello[#[who]]{Hello #[who]!}
%   |mshow|hello
% \end{example}
% \smallskip
%
% However, for readability, the delimiter can be changed to something
% else:
%   \named\def\hello[#[who]]{Hello #[who]!}
% \begin{example}[label=Argument delimited by \texttt{[} and \texttt{]},
%   commandchars=/<>,firstnumber=0]
%   \NamedDelim{|}{|}
%         \def\hello[#1]{Hello #1!}
%   \named\def\hello[#|who|]{Hello #|who|!}
%   /mshow/hello
% \end{example}
% \smallskip
%
% This example demonstrates multiple arguments and arbitrary
% \meta{parameter~text}:
%   \named\def\cfbox #[color] to #[width]#[content]{%
%           \fbox{\hbox to #[width]{\color{#[color]}#[content]}}}
% \begin{example}[label=More arguments]
%         \def\cfbox #1 to #2#3{\fbox{\hbox to #2{\color{#1}#3}}}
%   \named\def\cfbox #[color] to #[width]#[content]{%
%           \fbox{\hbox to #[width]{\color{#[color]}#[content]}}}
%   |mshow|cfbox
% \end{example}
% \smallskip
%
% \TeX's weird |#{| argument can be used as well:
%   \named\def\cbox #[color] to #[width]#{^^A
%      \hbox to #[width]\bgroup\color{#[color]}\let\next= }
% \begin{example}[label=Weird arguments]
%         \def\cbox #1 to #2#{\hbox to #2\bgroup\color{#1}\let\next= }
%   \named\def\cbox #[color] to #[width]#{%
%           \hbox to #[width]\bgroup\color{#[color]}\let\next= }
%   |mshow|cbox
% \end{example}
% \smallskip
%
%  {\NamedDelim XX
%   \named\xdef\test{\string#[arg]}}
% \begin{example}[commandchars=/<>, label=
%   \texttt{\string\edef} workaround \ref{sec:edef wa1}]
%         \edef\test{\string#[arg]}
%   \NamedDelim || /global/linenofalse
%   \named\edef\test{\string#[arg]} /global/linenofalse
%   \NamedDelim []
%   /mshow/test
% \end{example}
% \smallskip
%
%   \named\edef\test#[arg]{\iffalse{\fi\string}#[arg]}
% \begin{example}[label=
%   \texttt{\string\edef} workaround \ref{sec:edef wa2}]
%         \edef\test#1{\string}#1}
%   \named\edef\test#[arg]{\iffalse{\fi\string}#[arg]}
%   |mshow|test
% \end{example}
% \smallskip
%
%   \named\edef\test#[arg]{\string{#[arg]\iffalse}\fi}
% \begin{example}[label=
%   \texttt{\string\edef} workaround \ref{sec:edef wa3}]
%         \edef\test#1{\string{#1}
%   \named\edef\test#[arg]{\string{#[arg]\iffalse}\fi}
%   |mshow|test
% \end{example}
% \smallskip
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{namedef} Implementation}
%
%    \begin{macrocode}
%<*package>
%<@@=namedef>
%    \end{macrocode}
%
% \subsection{Loading}
%
% Load \pkg{expl3}, either through \cs{RequirePackage} or through
% inputting the generic loader, depending on the format in use
% (copied from Bruno Le Floch's \pkg{gtl}).
%    \begin{macrocode}
\begingroup\expandafter\expandafter\expandafter\endgroup
\expandafter\ifx\csname RequirePackage\endcsname\relax
  \input expl3-generic.tex
\else
  \RequirePackage{expl3}[2018-05-15]
\fi
\ExplSyntaxOn
\cs_if_exist:NTF \ProvidesExplPackage
  {
    \cs_new_eq:NN \@@_end_package_hook: \prg_do_nothing:
    \ExplSyntaxOff
    \ProvidesExplPackage
  }
  {
    \cs_new_eq:NN \@@_end_package_hook: \ExplSyntaxOff
    \group_begin:
    \ExplSyntaxOff
    \cs_set_protected:Npn \@@_tmp:w #1#2#3#4
      {
        \group_end:
        \tl_gset:cx { ver @ #1 . sty } { #2 ~ v#3 ~ #4 }
        \cs_if_exist_use:NF \wlog { \iow_log:x }
          { Package: ~ #1 ~ #2 ~ v#3 ~ #4 }
      }
    \@@_tmp:w
  }
      {namedef} {2019-05-15} {0.1}
      {Using named parameters in definitions (PHO)}
%    \end{macrocode}
%
% \subsection{Declarations}
%
% \begin{macro}{\flag @@_parm_count}
%   A flag (mis)used as a counter to keep track of the parameter number.
%    \begin{macrocode}
\flag_new:n { @@_parm_count }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\c_@@_prefix_tl}
%   A prefix to use as name space for temporary macros.
%    \begin{macrocode}
\tl_const:Nn \c_@@_prefix_tl { namedef~parm~-> }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_@@_macro_tl}
%   A token list to store the name of the macro meing defined for error
%   messages.
%    \begin{macrocode}
\tl_new:N \l_@@_macro_tl
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\q_@@_mark,\q_@@_stop}
%   Quarks used throughout the package.
%    \begin{macrocode}
\quark_new:N \q_@@_mark
\quark_new:N \q_@@_stop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\s_@@}
%   Scan mark used to skip code.
%    \begin{macrocode}
\scan_new:N \s_@@
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_skip_to_scan_mark:w, \@@_skip_to_scan_mark:nw}
%   Consume everything up to \cs{s_@@}.
%    \begin{macrocode}
\cs_new:Npn \@@_skip_to_scan_mark:w  #1    \s_@@ {  }
\cs_new:Npn \@@_skip_to_scan_mark:nw #1 #2 \s_@@ {#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_tmp:w}
%   A scratch macro.
%    \begin{macrocode}
\cs_new_eq:NN \@@_tmp:w ?
%    \end{macrocode}
% \end{macro}
%
% \subsection{The top-level \cs{named} macro}
%
% \begin{macro}{\named}
% \begin{macro}{\@@_grab_prefix:nN, \@@_start:nNp}
%   Starts scanning ahead for prefixes and the definition
%   command. Once finished the scanning of prefixes, call
%   \cs{@@_replace_begin:nNnn} to do the heavy lifting.
%    \begin{macrocode}
\cs_new_protected:Npn \named { \@@_grab_prefix:nN { } }
\cs_new:Npn \@@_grab_prefix:nN #1 #2
  {
    \@@_if_prefix:NTF #2
      { \@@_grab_prefix:nN }
      { \@@_start:nNp }
    { #1#2 }
  }
\cs_new:Npn \@@_start:nNp #1 #2 #3 #
  {
    \@@_detect_prefixes:nN {#1}
    \@@_replace_begin:nNnn      #2 {#3}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_if_prefix:N}
%   Checks against a list of valid prefixes and returns |true| or
%   |false| accordingly.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_prefix:N #1 { TF }
  {
    \if_int_compare:w 0
        \if_meaning:w \tex_protected:D #1 1 \fi:
        \if_meaning:w \tex_global:D    #1 1 \fi:
        \if_meaning:w \tex_outer:D     #1 1 \fi:
        \if_meaning:w \tex_long:D      #1 1 \fi:
        \if_meaning:w \scan_stop:      #1 1 \fi:
        = 1 \exp_stop_f:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_detect_prefixes:nN}
%   Defines a scratch macro \cs{@@_tmp:w} and queries its prefixes, then
%   forwards them to the the next macro to perform the parameter
%   replacement and definition.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_detect_prefixes:nN #1 #2
  {
    \cs_set_nopar:Npn \@@_tmp:w { }
    \use:x
      {
        \exp_not:N #2
          {
            \token_if_long_macro:NT \@@_tmp:w
               { \tex_long:D }
            \token_if_protected_macro:NT \@@_tmp:w
               { \tex_protected:D }
            \token_if_protected_long_macro:NT \@@_tmp:w
               { \tex_protected:D \tex_long:D }
            \exp_not:n {#1}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Main routine}
%
% \begin{macro}{\@@_replace_begin:nNnn, \@@_replace_parameter:Nn}
% \begin{macro}{\@@_parameter_output:nnw}
% \begin{macro}{\@@_define:nnnN}
%   Here the actual replacement of named parameters by numbered ones
%   takes place. A group is started to revert the flag and all the
%   defined temporary macros.
%
%   \cs{@@_replace_parameter:Nn} \cs{@@_in_parameter:nN} starts
%   replacing a dummy macro in the generic parameter replacement routine
%   by the macro which counts the parameters and aliases the named
%   parameters with numbered ones. Finally it starts
%   \cs{@@_replace_parm:Nn}, which scans the \meta{parameter~text} for
%   the named parameters and replaces them by numbered ones. The second
%   output argument of \cs{@@_replace_parm:Nn} is a list of definitions
%   which assign a number to each named parameter so that they can be
%   used in the next step.
%
%   \cs{@@_replace_parameter:Nn} \cs{@@_in_replacement:nN} then starts
%   by replacing the same dummy macro by one which will replace the
%   named parameter by its number. Again \cs{@@_replace_parm:Nn} is
%   started, and its output is the already-processed part of the
%   \meta{replacement~text}.
%
%   The output of both steps is inserted after \cs{@@_define:nnnN} (it's
%   missing two arguments in the definition of
%   \cs{@@_replace_begin:nNnn}). After all that is done, all the named
%   parameters were replaced by numbered ones, so \cs{@@_define:nnnN}
%   can do its thing.
%
%   A final quark is put in the input stream for recovery from errors.
%   In a successful run this quark is removed by \cs{@@_define:nnnN}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_replace_begin:nNnn #1 #2 #3 #4
  {
    \group_begin:
      \tl_set:Nx \l_@@_macro_tl
        {
          \token_if_active:NTF #2
            { \token_to_str:N #2 }
            { \c_backslash_str \cs_to_str:N #2 }
        }
      \@@_replace_parameter:Nn \@@_in_parameter:nN {#3}
      \@@_replace_parameter:Nn \@@_in_replacement:nN {#4}
      \@@_define:nnnN     {#1} #2
      \s_@@
  }
\cs_new_protected:Npn \@@_define:nnnN #1 #2 #3 #4
  {
    \group_end:
    \@@_skip_to_scan_mark:nw { #3#4#2{#1} }
  }
\cs_new:Npn \@@_replace_parameter:Nn #1 #2
  {
    \cs_set_eq:NN \@@_handle_parameter:nN #1
    \@@_replace_parm:Nn \@@_parameter_output:nnw {#2}
  }
\cs_new:Npn \@@_parameter_output:nnw #1 #2 #3 \@@_define:nnnN
  { #2 #3 \@@_define:nnnN {#1} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_in_parameter:nN, \@@_in_replacement:nN}
%   These two functions handle the named parameters when they are found
%   in the \meta{parameter~text} and \meta{replacement~text},
%   respectively.
%
%   \cs{@@_in_parameter:nN} checks if the named parameter already exists
%   (with \cs{relax} being |true|) and, in such case, throws an error
%   and aborts the definition.
%   \TODO{I should probably have it do the same as \TeX{} does, rather
%     than aborting\dots}
%   Otherwise the parameter is \cs{let} to
%   \cs{relax} so that if it is found later an error is issued. Setting
%   a macro to \cs{relax} is an expandable way to define it (the same
%   approach as in \pkg{l3flag}). After that,
%   the \cs{flag @@_parm_count} is raised once and its height is used as
%   the parameter number. The current parameter tokens and the parameter
%   number are flushed to the first (left) output slot, and a definition
%   |\cs_set:cpn {|\cs{c_@@_prefix_tl}~\meta{name}|} {|\meta{number}|}|
%   is appended to the second (right) output slot so that the names can
%   be used in the \meta{replacement~text}.
%    \begin{macrocode}
\cs_new:Npn \@@_in_parameter:nN #1
  {
    \if_cs_exist:w \c_@@_prefix_tl #1 \cs_end:
      \exp_after:wN \use_i:nn
    \else:
      \exp_after:wN \use_ii:nn
    \fi:
      {
        \msg_expandable_error:nnn { namedef } { repeated-parm } {#1}
        \@@_abort_definition:w
      }
      {
        \exp_after:wN \use_none:n \cs:w \c_@@_prefix_tl #1 \cs_end:
        \flag_raise:n { @@_parm_count }
        \exp_args:Nf \@@_append_output:nnNwnn
          { \flag_height:n { @@_parm_count } }
          {#1}
      }
  }
%    \end{macrocode}
%
%   \cs{@@_in_replacement:nN} also checks if the named parameter exists,
%   however now it will be \emph{not} be \cs{relax}, but the number
%   defined earlier, so \cs{cs_if_exist:cTF} can be safely used. If the
%   parameter does not exist it was never declared in the
%   \meta{parameter~text} (somewhat like |\def#1{#2}|), then raise an
%   error and abort.
%   \TODO{Probably shouldn't abort here either\dots}
%   Otherwise just flush |#|\meta{number}.
%    \begin{macrocode}
\cs_new:Npn \@@_in_replacement:nN #1
  {
    \cs_if_exist:cTF { \c_@@_prefix_tl #1 }
      {
        \exp_args:Nf \@@_append_output:nnNwnn
          { \use:c { \c_@@_prefix_tl #1 } }
          { }
      }
      {
        \msg_expandable_error:nnn { namedef } { unknown-parm } {#1}
        \@@_abort_definition:w
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Scanning routine}
%
% \begin{macro}{\@@_replace_parm:Nn}
% \begin{macro}{\@@_replace_loop:w}
% \begin{macro}{\@@_replace_end:wnn, \@@_flush:nw}
% \begin{macro}{\@@_append_output:nnNwnn}
% \begin{macro}{\@@_abort_definition:w}
%   \cs{@@_replace_parm:Nn} uses the same looping principle as in
%   \pkg{l3tl}'s \cs{__tl_act:NNNnn}.  It scans the input (here, the
%   \meta{parameter~text} and \meta{replacement~text}, separately) token
%   by token, differentiating spaces, braced tokens (groups), and
%   \enquote{normal} tokens.
%    \begin{macrocode}
\cs_new:Npn \@@_replace_parm:Nn #1 #2
  {
    \exp_after:wN #1
      \exp:w
      \@@_replace_loop:w #2
        \q_@@_mark \q_@@_stop { } { }
  }
\cs_new:Npn \@@_replace_loop:w #1 \q_@@_stop
  {
    \tl_if_head_is_N_type:nTF {#1}
      { \@@_replace_normal:N }
      {
        \tl_if_head_is_group:nTF {#1}
          { \@@_replace_group:n }
          { \@@_replace_space:w }
      }
    #1 \q_@@_stop
  }
\cs_new:Npn \@@_replace_end:wnn \q_@@_stop #1 #2
  { \exp_end: {#1} {#2} }
\cs_new:Npn \@@_flush:nw #1
    #2 \q_@@_stop #3 #4
  { \@@_replace_loop:w #2 \q_@@_stop { #3 #1 } {#4} }
%    \end{macrocode}
%
%   \cs{@@_append_output:nnNwnn} takes three arguments (a parameter
%   number, a parameter name, and a parameter token) and the two output
%   slots as |#5| and |#6|.  It appends the parameter token and number
%   to the first output slot, and a definition
%   |\cs_set:cpn {|\cs{c_@@_prefix_tl}~\meta{name}|} {|\meta{number}|}|
%   to the second output slot.
%    \begin{macrocode}
\cs_new:Npn \@@_append_output:nnNwnn #1 #2 #3
    #4 \q_@@_stop #5 #6
  {
    \@@_replace_loop:w #4 \q_@@_stop
      { #5 #3#1 }
      { #6 \cs_set:cpn { \c_@@_prefix_tl #2 } {#1} }
  }
%    \end{macrocode}
%
%   This macro doesn't really abort the definition at the time it's
%   called because it's called from within an |f|-expansion context, so
%   an attempt to end that prematurely will hardly end well.  Instead
%   it hijacks the process by inserting
%   \cs{@@_skip_to_scan_mark:w} in the second output slot, so that
%   the definition end as soon as the scanning ends.
%   \TODO{Can be simplified further.}
%    \begin{macrocode}
\cs_new:Npn \@@_abort_definition:w
    #1 \q_@@_stop #2 #3
  {
    \@@_replace_loop:w #1 \q_@@_stop
      {#2} { #3 \group_end: \@@_skip_to_scan_mark:w }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_replace_normal:N}
% \begin{macro}{\@@_replace_group:n, \@@_flush_group:nnw}
% \begin{macro}{\@@_replace_space:w}
%   Spaces are just passed through: they aren't parameter tokens nor
%   valid delimiters, so need no special treatment.
%
%   Braced tokens are recursively scanned by \cs{@@_replace_parm:Nn},
%   and the output is flushed inside a pair of braces (explicit catcode
%   $1$ and $2$ tokens are normalised to |{|_$1$ and |}|_$2$,
%   respectively)
%   \TODO{Since \cs{__tl_act:NNNnn} isn't used anymore, this doesn't
%   have to be |f|-expandable, so this restriciton can probably be
%   lifted.}
%
%   The remaining tokens are examined for their meaning.  If the token
%   is the quark \cs{q_@@_mark}, the scanning stops; if the token is a
%   parameter token, what follows is examined with \cs{@@_grab_parm:Nw}
%   to check if a replacement should be done; otherwise it's fluhsed to
%   the output.
%    \begin{macrocode}
\cs_new:Npn \@@_replace_normal:N #1
  {
    \token_if_eq_meaning:NNTF \q_@@_mark #1
      { \@@_replace_end:wnn }
      {
        \token_if_parameter:NTF #1
          { \@@_grab_parm:Nw }
          { \@@_flush:nw }
            {#1}
      }
  }
\cs_new:Npn \@@_replace_group:n #1
  { \@@_replace_parm:Nn \@@_flush_group:nnw {#1} }
\cs_new:Npn \@@_flush_group:nnw #1 #2
  { \@@_flush:nw { {#1} } }
\exp_last_unbraced:NNo
\cs_new:Npn \@@_replace_space:w \c_space_tl
  { \@@_flush:nw { ~ } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Parsing a parameter}
%
% \begin{macro}{\@@_grab_parm:Nw}
% \begin{macro}{\@@_grab_parm_aux:NNw, \@@_grab_parm_noop:NNw}
%   These macros are the final pieces of the parameter replacement
%   routine. \cs{@@_grab_parm:Nw} checks if the next token in the stream
%   is a valid |N|-type. If it is, then \cs{@@_grab_parm_aux:NNw} checks
%   if its character code is equal to \cs{l_@@_begin_name_token}, and if
%   it is, then call \cs{@@_grab_parm_do:Nw} to grab the named
%   parameter.  In all other cases, the tokens grabbed are not named
%   parameters, so they are flushed to the output.
%    \begin{macrocode}
\cs_new:Npn \@@_grab_parm:Nw #1 #2 \q_@@_stop
  {
    \tl_if_head_is_N_type:nTF {#2}
      { \@@_grab_parm_aux:NNw }
      { \@@_flush:nw }
        #1 #2 \q_@@_stop
  }
\cs_new:Npn \@@_grab_parm_aux:NNw #1 #2
  {
    \token_if_eq_charcode:NNTF \l_@@_begin_name_token #2
      { \@@_grab_parm_do:Nw }
      { \@@_grab_parm_noop:NNw }
        #1 #2
  }
%    \end{macrocode}
%
%   Here we have to take care not to flush \cs{q_@@_mark} to the output.
%    \begin{macrocode}
\cs_new:Npn \@@_grab_parm_noop:NNw #1 #2
  {
    \token_if_eq_meaning:NNTF \q_@@_mark #2
      { \@@_flush:nw { #1 } #2 }
      { \@@_flush:nw { #1 #2 } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Initialisation}
%
% \begin{macro}{\@@_grab_parm_do:Nw}
% \begin{macro}{\l_@@_begin_name_token, \l_@@_end_name_token}
%   These three hold the delimiters for named parameters.  They are
%   initialised here so that we can use \cs{named} (just to show off)
%   ahead, and they are redefined every time \cs{NamedDelim} is used.
%    \begin{macrocode}
\cs_new:Npn \@@_grab_parm_do:Nw #1 [ #2 ]
  { \@@_handle_parameter:nN {#2} #1 }
\cs_new_eq:NN \l_@@_begin_name_token [
\cs_new_eq:NN \l_@@_end_name_token ]
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\NamedDelim, \globalNamedDelim}
% \begin{macro}{\@@_named_delim_set:NNnn}
% \begin{macro}{\@@_check_delimiter:n}
%   At this point everything for the \cs{named} macro is set up,
%   so we can start using it. Now just some syntactic sugar to
%   allow the modification of the named argument delimiters.
%
%   Both \cs{NamedDelim} and \cs{globalNamedDelim} take two arguments,
%   an initial and final delimiters for the named argument. Both
%   delimters should be single non-control sequence tokens. Some of
%   these restrictions could be lifted, but it's not really necessary
%   because the choice of delimiter should not influence the working of
%   the code, only the readability. A code with |\NamedDelim[]| and
%   |\def\test#[1][#[2]]{[#[1]][#[2]]}| should work without problems;
%   the only restriction is that \cs{l_@@_end_name_token} (\emph{i.e.,}
%   the second argument of \cs{NamedDelim}) cannot appear in the
%   parameter name.
%    \begin{macrocode}
\cs_new_protected:Npn \NamedDelim
  { \@@_named_delim_set:NNnn \cs_set_eq:NN  \cs_set:Npn  }
\cs_new_protected:Npn \globalNamedDelim
  { \@@_named_delim_set:NNnn \cs_gset_eq:NN \cs_gset:Npn }
\named \cs_new_protected:Npn \@@_named_delim_set:NNnn
  #[let] #[def] #[begin] #[end]
  {
    \tl_trim_spaces_apply:nN {#[begin]} \@@_check_delimiter:n
    \tl_trim_spaces_apply:nN {#[end]}   \@@_check_delimiter:n
    #[let] \l_@@_begin_name_token #[begin]
    #[let] \l_@@_end_name_token #[end]
    #[def] \@@_grab_parm_do:Nw ##1 #[begin] ##2 #[end]
      { \@@_handle_parameter:nN {##2} ##1 }
    \s_@@
  }
%    \end{macrocode}
%
%   Here the \meta{token} is checked against a bunch of forbidden cases.
%    \begin{macrocode}
\named \cs_new_protected:Npn \@@_check_delimiter:n #[token]
  {
%    \end{macrocode}
%   It can't be empty (nor a space: they were trimmed above):
%    \begin{macrocode}
    \tl_if_empty:nT {#[token]}
      {
        \msg_error:nn { namedef } { blank-delim }
        \@@_skip_to_scan_mark:w
      }
%    \end{macrocode}
%   It can't be multiple tokens:
%    \begin{macrocode}
    \tl_if_single_token:nF {#[token]}
      {
        \msg_error:nnn { namedef } { multi-token-delim } {#[token]}
        \@@_skip_to_scan_mark:w
      }
%    \end{macrocode}
%   It can't be an active token:
%   \TODO{It probably can, but I have to add a few safety checks.}
%    \begin{macrocode}
    \token_if_active:NT #[token]
      {
        \msg_error:nnn { namedef } { macro-delim } {#[token]}
        \@@_skip_to_scan_mark:w
      }
%    \end{macrocode}
%   It can't be an implicit begin- or end-group token:
%    \begin{macrocode}
    \bool_lazy_or:nnT
        { \token_if_group_begin_p:N #[token] }
        { \token_if_group_end_p:N #[token] }
      {
        \msg_error:nnx { namedef } { group-delim }
          { \cs_to_str:N #[token] }
        \@@_skip_to_scan_mark:w
      }
%    \end{macrocode}
%   It can't be a parameter token:
%   \TODO{Maybe it can, but maybe it will be ambiguous.  Must check.}
%    \begin{macrocode}
    \token_if_parameter:NT #[token]
      {
        \msg_error:nnx { namedef } { param-delim }
          { \cs_to_str:N #[token] }
        \@@_skip_to_scan_mark:w
      }
%    \end{macrocode}
%   It can't be a control sequence:
%   \TODO{It probably can, but I'm not sure I want to allow this.}
%    \begin{macrocode}
    \token_if_cs:NT #[token]
      {
        \msg_error:nnx { namedef } { macro-delim }
          { \c_backslash_str \cs_to_str:N #[token] }
        \@@_skip_to_scan_mark:w
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Messages}
%
% Now we define the messages used throughout the package.
%
%    \begin{macrocode}
\msg_new:nnn { namedef } { repeated-parm }
  {
    Parameter~\iow_char:N\#[#1]~duplicated~in~
    definition~of~\l_@@_macro_tl.
  }
\msg_new:nnn { namedef } { unknown-parm }
  {
    Unknown~parameter~\iow_char:N\#[#1]~in~
    definition~of~\l_@@_macro_tl.
  }
\msg_new:nnn { namedef } { multi-token-delim }
  {
    Invalid~\iow_char:N\\named~parameter~delimiter~`#1'.~
    Delimiters~for~named~parameters~must~be~single~tokens.
  }
\msg_new:nnn { namedef } { macro-delim }
  {
    Invalid~\iow_char:N\\named~parameter~delimiter~`#1'.~
    Delimiters~for~named~parameters~can't~be~control~sequence~nor~
    active~characters.
  }
\msg_new:nnn { namedef } { group-delim }
  {
    Invalid~\iow_char:N\\named~parameter~delimiter~`\iow_char:N\\#1'.~
    Delimiters~for~named~parameters~can't~be~
      begin-/end-group~character~tokens.
  }
\msg_new:nnn { namedef } { blank-delim }
  {
    Invalid~\iow_char:N\\named~parameter~delimiter.~
    Delimiters~for~named~parameters~can't~be~empty~nor~space~tokens.
  }
\msg_new:nnn { namedef } { param-delim }
  {
    Invalid~\iow_char:N\\named~parameter~delimiter.~
    Delimiters~for~named~parameters~can't~be~parameter~tokens.
  }
%    \end{macrocode}
%
% Now execute the end package hook (in \LaTeX{} it is
% \cs{prg_do_nothing:}, but in plain \TeX{} it does \cs{ExplSyntaxOff}).
%
%    \begin{macrocode}
\@@_end_package_hook:
%    \end{macrocode}
%
% \iffalse
%</package>
% \fi
%
% \end{implementation}
%
%^^A \par\CodedocExplainEXP
%^^A \par\CodedocExplainREXP
%^^A \par\CodedocExplainTF
%
% \PrintIndex
%
\endinput
